<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⊙ Circumpunct Swarm Protocol</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&family=JetBrains+Mono:wght@300;400;500&display=swap');
        
        :root {
            --phi: 1.618033988749895;
            --gold: #D4AF37;
            --void: #0a0a0f;
            --field: #1a1a2e;
            --center: #e94560;
            --convergence: #533483;
            --text: #e8e8e8;
            --text-dim: #888;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Cormorant Garamond', Georgia, serif;
            background: var(--void);
            color: var(--text);
            min-height: 100vh;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(83, 52, 131, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(15, 52, 96, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(212, 175, 55, 0.05) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
        }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 2rem; }
        
        header {
            text-align: center;
            padding: 3rem 0;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            margin-bottom: 3rem;
        }
        
        .logo {
            font-size: 4rem;
            margin-bottom: 0.5rem;
            animation: pulse 4s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 20px var(--gold); }
            50% { opacity: 0.7; text-shadow: 0 0 40px var(--gold), 0 0 60px var(--center); }
        }
        
        h1 {
            font-weight: 300;
            font-size: 2.5rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--gold);
        }
        
        .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-top: 1rem;
        }
        
        .screen { display: none; }
        .screen.active { display: block; }
        
        .lobby-box {
            max-width: 500px;
            margin: 0 auto;
            background: linear-gradient(135deg, var(--field) 0%, var(--void) 100%);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            padding: 3rem;
            text-align: center;
        }
        
        .lobby-box h2 { color: var(--gold); font-weight: 400; margin-bottom: 1rem; }
        .lobby-box p { color: var(--text-dim); margin-bottom: 2rem; font-size: 1.1rem; }
        
        .room-input {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            padding: 1rem 1.5rem;
            border: 2px solid rgba(212, 175, 55, 0.4);
            border-radius: 8px;
            background: var(--void);
            color: var(--gold);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            width: 100%;
            max-width: 300px;
            margin-bottom: 1.5rem;
        }
        
        .room-input:focus { outline: none; border-color: var(--gold); }
        .room-input::placeholder { color: var(--text-dim); text-transform: none; letter-spacing: normal; }
        
        .btn {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            padding: 0.85rem 2rem;
            border: 1px solid var(--gold);
            background: transparent;
            color: var(--gold);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 0.25rem;
        }
        
        .btn:hover { background: var(--gold); color: var(--void); }
        .btn.primary { background: var(--gold); color: var(--void); }
        .btn.primary:hover { background: transparent; color: var(--gold); }
        
        .status { margin-top: 1rem; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--text-dim); }
        .status.error { color: var(--center); }
        
        .main-grid { display: grid; grid-template-columns: 1fr 400px; gap: 2rem; }
        @media (max-width: 1000px) { .main-grid { grid-template-columns: 1fr; } }
        
        .panel {
            background: linear-gradient(135deg, var(--field) 0%, var(--void) 100%);
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 8px;
            padding: 1.5rem;
            position: relative;
        }
        
        .panel::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; height: 2px;
            background: linear-gradient(90deg, transparent, var(--gold), transparent);
        }
        
        .panel-title {
            font-size: 1.2rem;
            color: var(--gold);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .panel-title .symbol { font-size: 1.5rem; }
        
        #swarm-canvas {
            width: 100%;
            height: 500px;
            background: radial-gradient(ellipse at center, var(--field) 0%, var(--void) 100%);
            border-radius: 50%;
            border: 2px solid rgba(212, 175, 55, 0.3);
        }
        
        .swarm-svg { width: 100%; height: 100%; }
        
        .connection-bar {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            margin-bottom: 1rem;
        }
        
        .status-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: var(--text-dim);
        }
        
        .status-dot.connected { background: #4ade80; box-shadow: 0 0 10px #4ade80; }
        .status-dot.pending { background: var(--gold); animation: blink 1s infinite; }
        
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        
        .room-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--gold);
            background: rgba(212, 175, 55, 0.1);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            margin-left: auto;
        }
        
        .drop-zone {
            border: 2px dashed rgba(212, 175, 55, 0.4);
            border-radius: 8px;
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1.5rem;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--gold);
            background: rgba(212, 175, 55, 0.05);
        }
        
        .drop-zone .icon { font-size: 3rem; margin-bottom: 1rem; opacity: 0.7; }
        .drop-zone input { display: none; }
        
        .file-list { max-height: 300px; overflow-y: auto; }
        
        .file-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .file-item:hover { background: rgba(212, 175, 55, 0.1); }
        .file-item .name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .file-item .size { color: var(--text-dim); }
        .file-item .owner { font-size: 0.7rem; color: var(--gold); }
        
        .progress-bar {
            height: 4px;
            background: var(--void);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.5rem;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--convergence), var(--gold), var(--center));
            transition: width 0.3s ease;
        }
        
        .log {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            background: var(--void);
            border-radius: 4px;
            padding: 1rem;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 1rem;
        }
        
        .log-entry { margin-bottom: 0.25rem; opacity: 0.8; }
        .log-entry.convergence { color: var(--convergence); }
        .log-entry.aperture { color: var(--gold); }
        .log-entry.emergence { color: var(--center); }
        .log-entry.error { color: #ef4444; }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(212, 175, 55, 0.2);
        }
        
        .info-item { text-align: center; }
        .info-value { font-size: 1.5rem; color: var(--gold); font-weight: 600; }
        .info-label { font-size: 0.75rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.1em; }
        
        .peer-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            margin-bottom: 0.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }
        
        .peer-item .id { color: var(--gold); }
        
        footer {
            text-align: center;
            padding: 3rem;
            color: var(--text-dim);
            font-size: 0.85rem;
            border-top: 1px solid rgba(212, 175, 55, 0.1);
            margin-top: 3rem;
        }
        
        .loader {
            width: 40px; height: 40px;
            border: 3px solid rgba(212, 175, 55, 0.2);
            border-top-color: var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">⊙</div>
            <h1>Circumpunct Swarm</h1>
            <div class="subtitle">Φ' = ☀︎ ∘ i ∘ ⊛[Φ] — Hybrid P2P File Transfer (WebRTC + Relay)</div>
        </header>
        
        <!-- LOBBY -->
        <div id="lobby-screen" class="screen active">
            <div class="lobby-box">
                <h2>Enter Swarm Name</h2>
                <p>Both peers enter the same name to connect!</p>
                <input type="text" class="room-input" id="room-input" placeholder="e.g. GOLDEN" maxlength="20" autofocus>
                <br>
                <button class="btn primary" id="join-btn">Join Swarm</button>
                <div class="status" id="lobby-status"></div>
            </div>
        </div>
        
        <!-- CONNECTING -->
        <div id="connecting-screen" class="screen">
            <div class="lobby-box">
                <h2>Swarm: <span id="room-display">---</span></h2>
                <div class="loader"></div>
                <p id="connecting-status">Connecting to swarm...</p>
                <button class="btn" id="cancel-btn" style="margin-top: 1rem;">Cancel</button>
            </div>
        </div>
        
        <!-- MAIN -->
        <div id="main-screen" class="screen">
            <div class="main-grid">
                <div class="panel">
                    <div class="panel-title"><span class="symbol">Φ</span><span>Swarm Field</span></div>
                    
                    <div class="connection-bar">
                        <div class="status-dot" id="connection-dot"></div>
                        <span id="connection-text">Connecting...</span>
                        <span class="room-display" id="room-tag">---</span>
                    </div>
                    
                    <div id="swarm-canvas">
                        <svg class="swarm-svg" viewBox="0 0 500 500">
                            <circle cx="250" cy="250" r="8" fill="#D4AF37">
                                <animate attributeName="r" values="6;10;6" dur="2s" repeatCount="indefinite"/>
                            </circle>
                            <circle cx="250" cy="250" r="80" fill="none" stroke="rgba(212,175,55,0.2)" stroke-width="1"/>
                            <circle cx="250" cy="250" r="130" fill="none" stroke="rgba(212,175,55,0.15)" stroke-width="1"/>
                            <circle cx="250" cy="250" r="180" fill="none" stroke="rgba(212,175,55,0.1)" stroke-width="1"/>
                            <g id="peer-nodes"></g>
                            <g id="flow-particles"></g>
                        </svg>
                    </div>
                    
                    <div class="info-grid">
                        <div class="info-item"><div class="info-value" id="peer-count">0</div><div class="info-label">Peers</div></div>
                        <div class="info-item"><div class="info-value" id="file-count">0</div><div class="info-label">Files</div></div>
                        <div class="info-item"><div class="info-value" id="transfer-rate">0</div><div class="info-label">KB/s</div></div>
                    </div>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                    <div class="panel">
                        <div class="panel-title"><span class="symbol">○</span><span>Connected Peers</span></div>
                        <div id="peer-list"><div style="color: var(--text-dim); font-size: 0.85rem;">Waiting for peers...</div></div>
                    </div>
                    
                    <div class="panel">
                        <div class="panel-title"><span class="symbol">•</span><span>Shared Files</span></div>
                        <div class="drop-zone" id="drop-zone">
                            <div class="icon">⊛</div>
                            <div>Drop file to share</div>
                            <div style="font-size: 0.8rem; color: var(--text-dim); margin-top: 0.5rem;">or click to select</div>
                            <input type="file" id="file-input">
                        </div>
                        <div class="file-list" id="file-list"></div>
                    </div>
                    
                    <div class="panel">
                        <div class="panel-title"><span class="symbol">i</span><span>Transfers</span></div>
                        <div id="transfer-list"><div style="color: var(--text-dim); font-size: 0.85rem;">No active transfers</div></div>
                        <div class="log" id="log"><div class="log-entry aperture">[⊙] Swarm ready</div></div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>⊙ Circumpunct Swarm Protocol v0.3</p>
            <p style="margin-top: 0.5rem;">Reality self-references: the future converges inward (⊛), rotates into existence (i), and emerges outward as pattern (☀︎)</p>
        </footer>
    </div>

    <script>
        const NTFY_SERVER = 'https://ntfy.sh';
        const PHI = 1.618033988749895;
        const CHUNK_SIZE = 65536; // 64KB chunks for WebRTC (much bigger now!)
        
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
        
        const state = {
            myId: 'P' + Math.random().toString(36).substr(2, 6).toUpperCase(),
            roomTopic: null,
            eventSource: null,
            peers: new Map(),           // peerId -> { lastSeen, connection, dataChannel, files }
            pendingConnections: new Map(), // peerId -> RTCPeerConnection (waiting for answer)
            sharedFiles: new Map(),
            remoteFiles: new Map(),
            transfers: new Map(),
            stats: { bytesIn: 0, bytesOut: 0, lastUpdate: Date.now() }
        };
        
        function log(message, type = 'aperture') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const symbols = { convergence: '⊛', aperture: 'i', emergence: '☀︎', error: '✗' };
            entry.textContent = `[${symbols[type] || '⊙'}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }
        
        function subscribe(roomName) {
            state.roomTopic = 'circumpunct-' + roomName.toUpperCase();
            state.eventSource = new EventSource(`${NTFY_SERVER}/${state.roomTopic}/sse`);
            
            state.eventSource.onopen = () => {
                document.getElementById('connecting-status').textContent = 'Connected! Announcing presence...';
                send({ type: 'join' });
                
                setTimeout(() => {
                    showScreen('main');
                    document.getElementById('room-tag').textContent = roomName.toUpperCase();
                    updateConnectionStatus(true);
                    log(`Joined swarm: ${roomName.toUpperCase()}`, 'emergence');
                    
                    setInterval(() => {
                        send({ type: 'heartbeat' });
                        cleanupPeers();
                    }, 10000);
                }, 500);
            };
            
            state.eventSource.onmessage = async (e) => {
                try {
                    const event = JSON.parse(e.data);
                    if (event.attachment?.url) {
                        const res = await fetch(event.attachment.url);
                        const msg = await res.json();
                        if (msg.from !== state.myId) handleMessage(msg);
                        return;
                    }
                    if (event.event === 'message' && event.message) {
                        try {
                            const msg = JSON.parse(event.message);
                            if (msg.from !== state.myId) handleMessage(msg);
                        } catch (e) {}
                    }
                } catch (err) {}
            };
            
            state.eventSource.onerror = () => updateConnectionStatus(false);
        }
        
        async function send(data) {
            if (!state.roomTopic) return;
            const msg = { ...data, from: state.myId, ts: Date.now() };
            try {
                await fetch(`${NTFY_SERVER}/${state.roomTopic}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(msg)
                });
            } catch (e) { console.error('Send error:', e); }
        }
        
        // Send directly to a peer via WebRTC data channel
        function sendToPeer(peerId, data) {
            const peer = state.peers.get(peerId);
            if (peer?.dataChannel?.readyState === 'open') {
                peer.dataChannel.send(JSON.stringify(data));
                return true;
            }
            return false;
        }
        
        // Broadcast to all connected peers via WebRTC
        function broadcast(data) {
            for (const [peerId, peer] of state.peers) {
                if (peer.dataChannel?.readyState === 'open') {
                    peer.dataChannel.send(JSON.stringify(data));
                }
            }
        }
        
        function handleMessage(msg) {
            switch (msg.type) {
                case 'join':
                    // New peer announced - initiate WebRTC connection
                    if (!state.peers.has(msg.from) && !state.pendingConnections.has(msg.from)) {
                        log(`Peer discovered: ${msg.from}`, 'convergence');
                        initiateWebRTC(msg.from);
                    }
                    break;
                case 'heartbeat':
                    // Keep peer alive even if WebRTC isn't connected yet
                    if (state.peers.has(msg.from)) {
                        state.peers.get(msg.from).lastSeen = Date.now();
                    }
                    break;
                case 'webrtc-offer':
                    handleWebRTCOffer(msg);
                    break;
                case 'webrtc-answer':
                    handleWebRTCAnswer(msg);
                    break;
                case 'webrtc-ice':
                    handleICECandidate(msg);
                    break;
                // Fallback for peers without WebRTC
                case 'manifest':
                    handleManifest(msg);
                    break;
                case 'request':
                    handleFileRequest(msg);
                    break;
                case 'chunk':
                    handleChunk(msg);
                    break;
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // WebRTC Connection Management
        // ═══════════════════════════════════════════════════════════════
        
        async function initiateWebRTC(peerId) {
            log(`Initiating WebRTC to ${peerId}...`, 'aperture');
            
            const pc = new RTCPeerConnection(rtcConfig);
            state.pendingConnections.set(peerId, pc);
            
            // Create data channel
            const channel = pc.createDataChannel('swarm', { ordered: true });
            setupDataChannel(channel, peerId, pc);
            
            // Handle ICE candidates
            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    send({ type: 'webrtc-ice', to: peerId, candidate: e.candidate });
                }
            };
            
            pc.onconnectionstatechange = () => {
                console.log(`Connection to ${peerId}: ${pc.connectionState}`);
                if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    state.pendingConnections.delete(peerId);
                }
            };
            
            // Create and send offer
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            // Wait for ICE gathering to complete
            await waitForICE(pc);
            
            send({ type: 'webrtc-offer', to: peerId, sdp: pc.localDescription });
            log(`Sent WebRTC offer to ${peerId}`, 'emergence');
        }
        
        async function handleWebRTCOffer(msg) {
            if (msg.to !== state.myId) return;
            
            log(`Received WebRTC offer from ${msg.from}`, 'convergence');
            
            const pc = new RTCPeerConnection(rtcConfig);
            
            pc.ondatachannel = (e) => {
                setupDataChannel(e.channel, msg.from, pc);
            };
            
            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    send({ type: 'webrtc-ice', to: msg.from, candidate: e.candidate });
                }
            };
            
            await pc.setRemoteDescription(msg.sdp);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            
            await waitForICE(pc);
            
            send({ type: 'webrtc-answer', to: msg.from, sdp: pc.localDescription });
            log(`Sent WebRTC answer to ${msg.from}`, 'emergence');
            
            state.pendingConnections.set(msg.from, pc);
        }
        
        async function handleWebRTCAnswer(msg) {
            if (msg.to !== state.myId) return;
            
            const pc = state.pendingConnections.get(msg.from);
            if (!pc) return;
            
            log(`Received WebRTC answer from ${msg.from}`, 'convergence');
            await pc.setRemoteDescription(msg.sdp);
        }
        
        async function handleICECandidate(msg) {
            if (msg.to !== state.myId) return;
            
            const pc = state.pendingConnections.get(msg.from) || state.peers.get(msg.from)?.connection;
            if (pc && msg.candidate) {
                try {
                    await pc.addIceCandidate(msg.candidate);
                } catch (e) {
                    console.log('ICE candidate error:', e);
                }
            }
        }
        
        function waitForICE(pc) {
            return new Promise((resolve) => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    const checkState = () => {
                        if (pc.iceGatheringState === 'complete') {
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            resolve();
                        }
                    };
                    pc.addEventListener('icegatheringstatechange', checkState);
                    // Timeout fallback
                    setTimeout(resolve, 2000);
                }
            });
        }
        
        function setupDataChannel(channel, peerId, pc) {
            channel.binaryType = 'arraybuffer';
            
            channel.onopen = () => {
                log(`⚡ Direct connection to ${peerId}!`, 'emergence');
                
                // Move from pending to active
                state.pendingConnections.delete(peerId);
                state.peers.set(peerId, {
                    lastSeen: Date.now(),
                    connection: pc,
                    dataChannel: channel,
                    files: new Map()
                });
                
                updatePeerList();
                updateVisualization();
                
                // Send our file manifest
                sendManifestToPeer(peerId);
            };
            
            channel.onclose = () => {
                log(`Connection closed: ${peerId}`, 'convergence');
                state.peers.delete(peerId);
                // Clean up their files
                for (const [fileId, file] of state.remoteFiles) {
                    if (file.owner === peerId) state.remoteFiles.delete(fileId);
                }
                updatePeerList();
                updateFileList();
                updateVisualization();
            };
            
            channel.onmessage = (e) => {
                try {
                    const msg = JSON.parse(e.data);
                    msg.from = peerId;
                    handlePeerMessage(msg);
                } catch (err) {
                    console.log('Data channel message error:', err);
                }
            };
        }
        
        // Handle messages received via WebRTC data channel
        function handlePeerMessage(msg) {
            switch (msg.type) {
                case 'manifest':
                    handleManifest(msg);
                    break;
                case 'request':
                    handleFileRequest(msg);
                    break;
                case 'chunk':
                    handleChunk(msg);
                    break;
            }
        }
        
        function addPeer(peerId) {
            if (peerId === state.myId) return;
            if (!state.peers.has(peerId)) {
                // Peer will be fully added when WebRTC connects
                // For now just note we've seen them
                log(`Peer discovered: ${peerId}`, 'convergence');
            }
        }
        
        function cleanupPeers() {
            const now = Date.now();
            for (const [peerId, peer] of state.peers) {
                if (now - peer.lastSeen > 30000) {
                    if (peer.connection) peer.connection.close();
                    state.peers.delete(peerId);
                    log(`Peer left: ${peerId}`, 'convergence');
                    for (const [fileId, file] of state.remoteFiles) {
                        if (file.owner === peerId) state.remoteFiles.delete(fileId);
                    }
                }
            }
            // Also clean up pending connections
            for (const [peerId, pc] of state.pendingConnections) {
                if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                    state.pendingConnections.delete(peerId);
                }
            }
            updatePeerList();
            updateFileList();
            updateVisualization();
        }
        
        async function shareFile(file) {
            const fileId = state.myId + '_' + Date.now();
            
            // Read file as ArrayBuffer for WebRTC
            const arrayBuffer = await file.arrayBuffer();
            const totalChunks = Math.ceil(arrayBuffer.byteLength / CHUNK_SIZE);
            
            state.sharedFiles.set(fileId, { 
                name: file.name, 
                size: file.size, 
                mimeType: file.type, 
                data: arrayBuffer,
                totalChunks 
            });
            
            log(`Sharing: ${file.name} (${totalChunks} chunks)`, 'emergence');
            updateFileList();
            
            // Send manifest to all connected peers
            broadcastManifest();
        }
        
        function sendManifestToPeer(peerId) {
            const files = [];
            for (const [fileId, file] of state.sharedFiles) {
                files.push({ id: fileId, name: file.name, size: file.size, chunks: file.totalChunks });
            }
            sendToPeer(peerId, { type: 'manifest', files });
        }
        
        function broadcastManifest() {
            const files = [];
            for (const [fileId, file] of state.sharedFiles) {
                files.push({ id: fileId, name: file.name, size: file.size, chunks: file.totalChunks });
            }
            broadcast({ type: 'manifest', files });
        }
        
        // Legacy - keep for fallback
        function sendManifest() {
            const files = [];
            for (const [fileId, file] of state.sharedFiles) {
                files.push({ id: fileId, name: file.name, size: file.size, chunks: file.totalChunks });
            }
            if (files.length > 0 || state.peers.size > 0) send({ type: 'manifest', files });
        }
        
        function handleManifest(msg) {
            for (const file of msg.files) {
                state.remoteFiles.set(file.id, { ...file, owner: msg.from });
            }
            log(`${msg.from} sharing ${msg.files.length} file(s)`, 'convergence');
            updateFileList();
        }
        
        function requestFile(fileId) {
            const file = state.remoteFiles.get(fileId);
            if (!file) return;
            
            const transferId = fileId + '_' + Date.now();
            state.transfers.set(transferId, {
                fileId, name: file.name, size: file.size, owner: file.owner,
                totalChunks: file.chunks, receivedChunks: new Set(), 
                data: new Array(file.chunks).fill(null),
                mimeType: null
            });
            
            log(`Requesting: ${file.name} (${file.chunks} chunks)`, 'convergence');
            updateTransferList();
            
            // Request all chunks - peer will send them
            const requestMsg = { type: 'request', fileId, transferId, totalChunks: file.chunks };
            
            // Try WebRTC first, fall back to ntfy
            if (!sendToPeer(file.owner, requestMsg)) {
                send({ ...requestMsg, to: file.owner });
            }
            
            animateFlow('convergence');
        }
        
        function handleFileRequest(msg) {
            const file = state.sharedFiles.get(msg.fileId);
            if (!file) return;
            
            log(`Sending ${file.name} to ${msg.from}`, 'emergence');
            
            // Send chunks
            for (let i = 0; i < file.totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, file.data.byteLength);
                const chunkData = file.data.slice(start, end);
                
                // Convert to base64 for JSON transport
                const base64 = btoa(String.fromCharCode(...new Uint8Array(chunkData)));
                
                const chunkMsg = {
                    type: 'chunk',
                    fileId: msg.fileId,
                    transferId: msg.transferId,
                    chunkIndex: i,
                    totalChunks: file.totalChunks,
                    data: base64,
                    name: file.name,
                    mimeType: file.mimeType,
                    size: chunkData.byteLength
                };
                
                // Use WebRTC if available
                if (!sendToPeer(msg.from, chunkMsg)) {
                    send({ ...chunkMsg, to: msg.from });
                }
                
                state.stats.bytesOut += chunkData.byteLength;
            }
            
            animateFlow('emergence');
        }
        
        function handleChunk(msg) {
            let transfer = state.transfers.get(msg.transferId);
            if (!transfer) {
                transfer = {
                    fileId: msg.fileId, name: msg.name, totalChunks: msg.totalChunks,
                    receivedChunks: new Set(), data: new Array(msg.totalChunks).fill(null), 
                    mimeType: msg.mimeType
                };
                state.transfers.set(msg.transferId, transfer);
            }
            
            if (!transfer.receivedChunks.has(msg.chunkIndex)) {
                // Decode base64 to binary
                const binary = atob(msg.data);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                
                transfer.data[msg.chunkIndex] = bytes;
                transfer.receivedChunks.add(msg.chunkIndex);
                transfer.mimeType = msg.mimeType || transfer.mimeType;
                state.stats.bytesIn += bytes.length;
                
                const progress = Math.round((transfer.receivedChunks.size / transfer.totalChunks) * 100);
                if (progress % 20 === 0 || transfer.receivedChunks.size === transfer.totalChunks) {
                    log(`${transfer.name}: ${progress}%`, 'convergence');
                }
                
                updateTransferList();
                animateFlow('convergence');
                
                if (transfer.receivedChunks.size === transfer.totalChunks) {
                    completeDownload(msg.transferId, transfer);
                }
            }
        }
        
        function completeDownload(transferId, transfer) {
            log(`Download complete: ${transfer.name}`, 'emergence');
            
            // Combine chunks into single ArrayBuffer
            const totalSize = transfer.data.reduce((sum, chunk) => sum + chunk.length, 0);
            const combined = new Uint8Array(totalSize);
            let offset = 0;
            for (const chunk of transfer.data) {
                combined.set(chunk, offset);
                offset += chunk.length;
            }
            
            const blob = new Blob([combined], { type: transfer.mimeType || 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = transfer.name;
            a.click();
            URL.revokeObjectURL(url);
            state.transfers.delete(transferId);
            updateTransferList();
        }
        
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id + '-screen').classList.add('active');
        }
        
        function updateConnectionStatus(connected) {
            const dot = document.getElementById('connection-dot');
            const text = document.getElementById('connection-text');
            dot.className = connected ? 'status-dot connected' : 'status-dot';
            text.textContent = connected ? `Connected as ${state.myId}` : 'Disconnected';
        }
        
        function updatePeerList() {
            const listEl = document.getElementById('peer-list');
            const totalPeers = state.peers.size + state.pendingConnections.size;
            
            if (totalPeers === 0) {
                listEl.innerHTML = '<div style="color: var(--text-dim); font-size: 0.85rem;">Waiting for peers...</div>';
            } else {
                listEl.innerHTML = '';
                
                // Connected peers (WebRTC established)
                for (const [peerId, peer] of state.peers) {
                    const item = document.createElement('div');
                    item.className = 'peer-item';
                    item.innerHTML = `
                        <div class="status-dot connected"></div>
                        <span class="id">${peerId}</span>
                        <span style="margin-left: auto; font-size: 0.65rem; color: #4ade80;">⚡ direct</span>
                    `;
                    listEl.appendChild(item);
                }
                
                // Pending connections
                for (const [peerId] of state.pendingConnections) {
                    const item = document.createElement('div');
                    item.className = 'peer-item';
                    item.innerHTML = `
                        <div class="status-dot pending"></div>
                        <span class="id">${peerId}</span>
                        <span style="margin-left: auto; font-size: 0.65rem; color: var(--gold);">connecting...</span>
                    `;
                    listEl.appendChild(item);
                }
            }
            document.getElementById('peer-count').textContent = state.peers.size;
        }
        
        function updateFileList() {
            const listEl = document.getElementById('file-list');
            listEl.innerHTML = '';
            let totalFiles = 0;
            
            for (const [fileId, file] of state.sharedFiles) {
                totalFiles++;
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `<span style="color: var(--gold);">⊙</span><span class="name">${file.name}</span><span class="size">${formatSize(file.size)}</span><span class="owner">you</span>`;
                listEl.appendChild(item);
            }
            
            for (const [fileId, file] of state.remoteFiles) {
                totalFiles++;
                const item = document.createElement('div');
                item.className = 'file-item';
                item.style.cursor = 'pointer';
                item.innerHTML = `<span style="color: var(--convergence);">⊛</span><span class="name">${file.name}</span><span class="size">${formatSize(file.size)}</span><span class="owner">${file.owner}</span>`;
                item.onclick = () => requestFile(fileId);
                listEl.appendChild(item);
            }
            
            document.getElementById('file-count').textContent = totalFiles;
        }
        
        function updateTransferList() {
            const listEl = document.getElementById('transfer-list');
            if (state.transfers.size === 0) {
                listEl.innerHTML = '<div style="color: var(--text-dim); font-size: 0.85rem;">No active transfers</div>';
                return;
            }
            listEl.innerHTML = '';
            for (const [transferId, transfer] of state.transfers) {
                const received = transfer.receivedChunks instanceof Set ? transfer.receivedChunks.size : transfer.receivedChunks.length;
                const progress = (received / transfer.totalChunks) * 100;
                const item = document.createElement('div');
                item.className = 'file-item';
                item.style.flexDirection = 'column';
                item.style.alignItems = 'stretch';
                item.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <span style="color: var(--center);">☀︎</span>
                        <span class="name">${transfer.name}</span>
                        <span class="size">${Math.round(progress)}%</span>
                    </div>
                    <div class="progress-bar"><div class="progress-fill" style="width: ${progress}%"></div></div>`;
                listEl.appendChild(item);
            }
        }
        
        function updateVisualization() {
            const container = document.getElementById('peer-nodes');
            container.innerHTML = '';
            const peers = Array.from(state.peers.keys());
            const angleStep = (2 * Math.PI) / Math.max(peers.length, 1);
            
            peers.forEach((peerId, i) => {
                const angle = angleStep * i - Math.PI / 2;
                const x = 250 + 120 * Math.cos(angle);
                const y = 250 + 120 * Math.sin(angle);
                const node = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                node.innerHTML = `
                    <line x1="250" y1="250" x2="${x}" y2="${y}" stroke="rgba(212,175,55,0.3)" stroke-width="1" stroke-dasharray="5,5"/>
                    <circle cx="${x}" cy="${y}" r="12" fill="#0f3460" stroke="#D4AF37" stroke-width="2"/>
                    <text x="${x}" y="${y + 4}" text-anchor="middle" fill="#D4AF37" font-size="8">○</text>`;
                container.appendChild(node);
            });
        }
        
        function animateFlow(direction) {
            const container = document.getElementById('flow-particles');
            const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            const angle = Math.random() * Math.PI * 2;
            const startR = direction === 'convergence' ? 180 : 30;
            const endR = direction === 'convergence' ? 30 : 180;
            const startX = 250 + startR * Math.cos(angle), startY = 250 + startR * Math.sin(angle);
            const endX = 250 + endR * Math.cos(angle), endY = 250 + endR * Math.sin(angle);
            
            particle.setAttribute('cx', startX);
            particle.setAttribute('cy', startY);
            particle.setAttribute('r', '4');
            particle.setAttribute('fill', direction === 'convergence' ? '#533483' : '#e94560');
            container.appendChild(particle);
            
            const startTime = Date.now();
            function animate() {
                const progress = Math.min((Date.now() - startTime) / 1000, 1);
                const eased = 1 - Math.pow(1 - progress, PHI);
                particle.setAttribute('cx', startX + (endX - startX) * eased);
                particle.setAttribute('cy', startY + (endY - startY) * eased);
                particle.setAttribute('opacity', 1 - progress);
                if (progress < 1) requestAnimationFrame(animate);
                else particle.remove();
            }
            requestAnimationFrame(animate);
        }
        
        setInterval(() => {
            const elapsed = (Date.now() - state.stats.lastUpdate) / 1000;
            const rate = (state.stats.bytesIn + state.stats.bytesOut) / elapsed / 1024;
            document.getElementById('transfer-rate').textContent = rate.toFixed(1);
            state.stats.bytesIn = 0;
            state.stats.bytesOut = 0;
            state.stats.lastUpdate = Date.now();
        }, 1000);
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('join-btn').onclick = () => {
                const roomName = document.getElementById('room-input').value.trim();
                if (roomName.length < 2) {
                    document.getElementById('lobby-status').textContent = 'Enter a name (2+ characters)';
                    document.getElementById('lobby-status').className = 'status error';
                    return;
                }
                document.getElementById('room-display').textContent = roomName.toUpperCase();
                showScreen('connecting');
                subscribe(roomName);
            };
            
            document.getElementById('room-input').onkeypress = (e) => {
                if (e.key === 'Enter') document.getElementById('join-btn').click();
            };
            
            document.getElementById('cancel-btn').onclick = () => {
                if (state.eventSource) state.eventSource.close();
                showScreen('lobby');
            };
            
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            
            dropZone.onclick = () => fileInput.click();
            dropZone.ondragover = (e) => { e.preventDefault(); dropZone.classList.add('dragover'); };
            dropZone.ondragleave = () => dropZone.classList.remove('dragover');
            dropZone.ondrop = (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) shareFile(e.dataTransfer.files[0]);
            };
            fileInput.onchange = (e) => {
                if (e.target.files.length > 0) shareFile(e.target.files[0]);
            };
        });
    </script>
</body>
</html>
