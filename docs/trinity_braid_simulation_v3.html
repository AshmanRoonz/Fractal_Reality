<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trinity Braid Simulation - Circumpunct V5.3.1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #0f0f1e 100%);
            font-family: 'Georgia', serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            perspective: 1200px;
            position: relative;
        }

        .equation {
            font-size: 48px;
            color: white;
            margin-bottom: 60px;
            opacity: 0;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            transition: opacity 2s ease;
        }

        .trinity-container {
            display: flex;
            gap: 80px;
            transform-style: preserve-3d;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            transition: transform 3s ease, left 8s ease;
        }

        .circumpunct {
            width: 120px;
            height: 120px;
            position: relative;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .circle {
            width: 100%;
            height: 100%;
            border: 4px solid;
            border-radius: 50%;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .center-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .soul { color: #ff3366; }
        .soul .center-dot { background: #ff3366; box-shadow: 0 0 20px #ff3366; }

        .body { color: #33ff66; }
        .body .center-dot { background: #33ff66; box-shadow: 0 0 20px #33ff66; }

        .mind { color: #3366ff; }
        .mind .center-dot { background: #3366ff; box-shadow: 0 0 20px #3366ff; }

        .label {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            opacity: 0.8;
            white-space: nowrap;
        }

        .braid-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
            pointer-events: none;
        }

        .info-text {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            opacity: 0;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            transition: opacity 1s ease;
            max-width: 90%;
        }

        .top-text {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            opacity: 0;
            transition: opacity 2s ease;
            text-align: center;
            max-width: 90%;
        }

        .top-text-sub {
            font-size: 16px;
            margin-top: 10px;
            opacity: 0.7;
        }

        .visible {
            opacity: 1 !important;
        }

        .rotating {
            transform: translateX(-50%) rotateY(90deg) rotateX(15deg) !important;
        }

        .phase-4 .trinity-container {
            left: 120%;
        }

        .restart-button {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-family: 'Georgia', serif;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .restart-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.2);
        }

        .restart-button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <button class="restart-button" onclick="restartPresentation()">⟲ Restart</button>
    
    <div class="container" id="container">
        <div class="equation" id="equation">⊙ = ⊙₁ ⊗ ⊙₂ ⊗ ⊙₃</div>

        <div class="trinity-container" id="trinity">
            <div class="circumpunct" id="soul-circle">
                <div class="circle soul">
                    <div class="center-dot"></div>
                </div>
                <div class="label">⊙₁ Soul</div>
            </div>

            <div class="circumpunct" id="body-circle">
                <div class="circle body">
                    <div class="center-dot"></div>
                </div>
                <div class="label">⊙₂ Body</div>
            </div>

            <div class="circumpunct" id="mind-circle">
                <div class="circle mind">
                    <div class="center-dot"></div>
                </div>
                <div class="label">⊙₃ Mind</div>
            </div>
        </div>

        <canvas class="braid-canvas" id="braidCanvas"></canvas>

        <div class="info-text" id="infoText">Every whole is three wholes in tensor product</div>

        <div class="top-text" id="topText">
            <div>B₃ Braid Group: Minimum Structure for History</div>
            <div class="top-text-sub">Yang-Baxter: Å₁₂ ∘ Å₂₃ ∘ Å₁₂ = Å₂₃ ∘ Å₁₂ ∘ Å₂₃</div>
        </div>
    </div>

    <script>
        // Phase management
        let currentPhase = 1;
        const elements = {
            container: document.getElementById('container'),
            equation: document.getElementById('equation'),
            trinity: document.getElementById('trinity'),
            soulCircle: document.getElementById('soul-circle'),
            bodyCircle: document.getElementById('body-circle'),
            mindCircle: document.getElementById('mind-circle'),
            braidCanvas: document.getElementById('braidCanvas'),
            infoText: document.getElementById('infoText'),
            topText: document.getElementById('topText')
        };

        // Canvas setup
        const canvas = elements.braidCanvas;
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Strand origins (will be set based on circumpunct positions in phase 4)
        const strands = [
            { y: 0, color: '#ff3366', name: 'Soul', amplitude: 40, frequency: 0.015, phaseShift: 0 },
            { y: 0, color: '#33ff66', name: 'Body', amplitude: 40, frequency: 0.015, phaseShift: Math.PI * 2/3 },
            { y: 0, color: '#3366ff', name: 'Mind', amplitude: 40, frequency: 0.015, phaseShift: Math.PI * 4/3 }
        ];

        let animationProgress = 0;
        let animationStartTime = null;
        let braiding = false;
        let braidOriginX = 0;
        let braidCenterX = 0;
        let loopingBraid = false;
        let loopStartTime = null;

        // Calculate strand positions for braiding
        function getStrandPosition(strand, x, direction = 1) {
            // direction: 1 for left (past), -1 for right (future/present)
            const y = strand.y + strand.amplitude * Math.sin(x * strand.frequency * direction + strand.phaseShift);
            return y;
        }

        // Draw a braided strand in one direction
        function drawStrandDirection(strand, length, originX, direction) {
            // direction: -1 for leftward (past), 1 for rightward (following present)
            ctx.strokeStyle = strand.color;
            ctx.lineWidth = 10;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = 0.9;

            ctx.beginPath();
            ctx.moveTo(originX, strand.y);

            let lastX = originX;
            let lastY = strand.y;

            for (let x = 0; x <= length; x += 3) {
                const y = getStrandPosition(strand, x, direction);
                const drawX = originX + (x * direction);
                ctx.lineTo(drawX, y);
                lastX = drawX;
                lastY = y;
            }

            ctx.stroke();

            // Outer glow for coaxial effect
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 18;
            ctx.stroke();

            // Draw animated end point (only on the left/past side)
            if (direction === -1 && length > 20) {
                ctx.globalAlpha = 1;
                ctx.fillStyle = strand.color;
                ctx.beginPath();
                ctx.arc(lastX, lastY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(lastX, lastY, 16, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Animation loop for braids
        function animateBraids(timestamp) {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsed = timestamp - animationStartTime;
            
            // Two phases: expansion (0-8s) and continuous movement (8s+)
            const expansionDuration = 8000;
            const isExpanding = elapsed < expansionDuration;
            
            if (isExpanding) {
                animationProgress = elapsed / expansionDuration;
            } else {
                animationProgress = 1;
                if (!loopingBraid) {
                    loopingBraid = true;
                    loopStartTime = timestamp;
                }
            }
            
            // Calculate how much to move rightward (starts immediately)
            const moveDuration = 12000; // 12 seconds to move off screen
            const moveProgress = Math.min(elapsed / moveDuration, 1);
            const moveDistance = canvas.width * 0.7 * moveProgress; // Move 70% of screen width
            
            // Current braid center position (moves right from the start)
            const currentBraidCenter = braidCenterX + moveDistance;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const maxLength = Math.max(currentBraidCenter, canvas.width - currentBraidCenter);
            const currentLength = maxLength * animationProgress;
            
            // Calculate phase shift for flowing animation
            let phaseShift = 0;
            if (loopingBraid && loopStartTime) {
                const loopElapsed = timestamp - loopStartTime;
                const loopDuration = 3000;
                phaseShift = (loopElapsed % loopDuration) / loopDuration * Math.PI * 2;
            }
            
            // Draw strands expanding from moving center
            strands.forEach(strand => {
                const animatedStrand = {
                    ...strand,
                    phaseShift: strand.phaseShift + phaseShift
                };
                
                // Left (past) - accumulated history only
                drawStrandDirection(animatedStrand, currentLength, currentBraidCenter, -1);
            });
            
            requestAnimationFrame(animateBraids);
        }

        let timeouts = [];

        // Phase transitions
        function startPhase1() {
            elements.equation.classList.add('visible');
            elements.infoText.textContent = "Every whole is three wholes in tensor product";
            elements.infoText.classList.add('visible');
        }

        function startPhase2() {
            elements.equation.classList.remove('visible');
            elements.trinity.style.position = 'absolute';
            elements.trinity.style.left = '50%';
            elements.trinity.style.transform = 'translateX(-50%)';
            
            elements.soulCircle.classList.add('visible');
            
            timeouts.push(setTimeout(() => {
                elements.bodyCircle.classList.add('visible');
            }, 300));
            
            timeouts.push(setTimeout(() => {
                elements.mindCircle.classList.add('visible');
            }, 600));

            elements.infoText.textContent = "⊙₁ (Soul) ⊗ ⊙₂ (Body) ⊗ ⊙₃ (Mind)";
        }

        function startPhase3() {
            elements.infoText.classList.remove('visible');
            
            timeouts.push(setTimeout(() => {
                elements.trinity.classList.add('rotating');
                elements.infoText.textContent = "Rotating to side view...";
                elements.infoText.classList.add('visible');
            }, 100));
        }

        function startPhase4() {
            elements.container.classList.add('phase-4');
            elements.infoText.classList.remove('visible');
            
            // Wait for rotation to complete, then calculate exact positions
            timeouts.push(setTimeout(() => {
                // Get the actual screen positions of the circumpunct center dots
                const soulRect = elements.soulCircle.querySelector('.center-dot').getBoundingClientRect();
                const bodyRect = elements.bodyCircle.querySelector('.center-dot').getBoundingClientRect();
                const mindRect = elements.mindCircle.querySelector('.center-dot').getBoundingClientRect();
                
                // Set strand Y positions to match the center dots exactly
                strands[0].y = soulRect.top + soulRect.height / 2;
                strands[1].y = bodyRect.top + bodyRect.height / 2;
                strands[2].y = mindRect.top + mindRect.height / 2;
                
                // Set the center X position where braiding happens
                braidCenterX = bodyRect.left + bodyRect.width / 2;
                
                elements.braidCanvas.classList.add('visible');
                elements.infoText.textContent = "Worldlines braiding through spacetime - History as geometric topology";
                elements.infoText.classList.add('visible');
                
                // Start braid animation
                animationStartTime = null;
                animationProgress = 0;
                braiding = true;
                loopingBraid = false;
                requestAnimationFrame(animateBraids);
            }, 1000));

            timeouts.push(setTimeout(() => {
                elements.topText.classList.add('visible');
            }, 4000));
        }

        // Main timeline
        function startPresentation() {
            timeouts.push(setTimeout(startPhase1, 100));
            timeouts.push(setTimeout(startPhase2, 4000));
            timeouts.push(setTimeout(startPhase3, 8000));
            timeouts.push(setTimeout(startPhase4, 12000));
        }

        // Restart function
        function restartPresentation() {
            // Clear all timeouts
            timeouts.forEach(t => clearTimeout(t));
            timeouts = [];
            
            // Reset animation state
            animationProgress = 0;
            animationStartTime = null;
            braiding = false;
            loopingBraid = false;
            loopStartTime = null;
            currentPhase = 1;
            
            // Reset all elements
            elements.equation.classList.remove('visible');
            elements.soulCircle.classList.remove('visible');
            elements.bodyCircle.classList.remove('visible');
            elements.mindCircle.classList.remove('visible');
            elements.trinity.classList.remove('rotating');
            elements.braidCanvas.classList.remove('visible');
            elements.infoText.classList.remove('visible');
            elements.topText.classList.remove('visible');
            elements.container.classList.remove('phase-4');
            
            // Reset trinity position
            elements.trinity.style.left = '50%';
            elements.trinity.style.transform = 'translateX(-50%)';
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Start fresh
            startPresentation();
        }

        // Start on load
        startPresentation();
    </script>
</body>
</html>
