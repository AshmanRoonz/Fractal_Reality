<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pokemon Chess</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            min-height: 100dvh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            overflow-x: hidden;
        }

        h1 {
            color: #ffcb05;
            text-shadow: 3px 3px 0 #3466af, -1px -1px 0 #3466af;
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            margin-bottom: 10px;
            letter-spacing: 2px;
            text-align: center;
        }

        .game-info {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            width: 100%;
            max-width: 500px;
            justify-content: center;
        }

        .player-info {
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 12px;
            color: white;
            text-align: center;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            flex: 1;
            max-width: 160px;
        }

        .player-info.active {
            border-color: #ffcb05;
            box-shadow: 0 0 15px rgba(255, 203, 5, 0.5);
            transform: scale(1.05);
        }

        .player-info h3 {
            margin-bottom: 3px;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }

        .player-info .captures {
            font-size: clamp(0.7rem, 2.5vw, 0.85rem);
            opacity: 0.8;
            margin-top: 5px;
        }

        .player-info small {
            font-size: clamp(0.6rem, 2vw, 0.8rem);
        }

        .player-red { color: #ff6b6b; }
        .player-blue { color: #4ecdc4; }

        #loading {
            color: white;
            font-size: 1.2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .pokeball-loader {
            width: 50px;
            height: 50px;
            background: linear-gradient(to bottom, #ff1a1a 50%, white 50%);
            border-radius: 50%;
            position: relative;
            animation: spin 1s linear infinite;
            border: 4px solid #333;
        }

        .pokeball-loader::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 4px;
            background: #333;
            top: 50%;
            transform: translateY(-50%);
        }

        .pokeball-loader::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border: 4px solid #333;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #game-container {
            display: none;
            width: 100%;
            max-width: 600px;
            flex-direction: column;
            align-items: center;
        }

        #game-container.visible {
            display: flex;
        }

        :root {
            --cell-size: min(11vw, 70px);
            --piece-size: calc(var(--cell-size) * 1.15);
            --sprite-size: calc(var(--cell-size) * 1.15);
        }

        #board {
            display: grid;
            grid-template-columns: repeat(8, var(--cell-size));
            grid-template-rows: repeat(8, var(--cell-size));
            border: clamp(4px, 1.5vw, 8px) solid #5d4e37;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            touch-action: manipulation;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .cell.light {
            background: #f0d9b5;
        }

        .cell.dark {
            background: #b58863;
        }

        .cell.valid-move {
            cursor: pointer;
        }

        .cell.valid-move::after {
            content: '';
            position: absolute;
            width: calc(var(--cell-size) * 0.35);
            height: calc(var(--cell-size) * 0.35);
            background: rgba(100, 200, 100, 0.7);
            border-radius: 50%;
            z-index: 1;
            animation: pulse 1s infinite;
        }

        .cell.valid-capture::after {
            content: '';
            position: absolute;
            width: calc(var(--cell-size) * 0.9);
            height: calc(var(--cell-size) * 0.9);
            background: transparent;
            border: 4px solid rgba(255, 100, 100, 0.8);
            border-radius: 50%;
            z-index: 1;
        }

        .cell.in-check {
            background: rgba(255, 0, 0, 0.5) !important;
            animation: checkPulse 1s infinite;
        }

        @keyframes checkPulse {
            0%, 100% { background: rgba(255, 0, 0, 0.3); }
            50% { background: rgba(255, 0, 0, 0.6); }
        }

        .cell.last-move {
            background: rgba(255, 255, 0, 0.3);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        .piece {
            width: var(--piece-size);
            height: var(--piece-size);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, filter 0.2s;
            position: relative;
            z-index: 2;
        }

        .piece:hover {
            transform: scale(1.15);
            z-index: 5;
        }

        .piece.red img {
            filter: drop-shadow(0 0 3px rgba(255, 100, 100, 0.8)) 
                    drop-shadow(0 3px 5px rgba(0,0,0,0.4));
        }

        .piece.blue img {
            filter: drop-shadow(0 0 3px rgba(78, 205, 196, 0.8)) 
                    drop-shadow(0 3px 5px rgba(0,0,0,0.4));
        }

        .piece.selected {
            transform: scale(1.25);
            z-index: 10;
            animation: bounce 0.5s ease infinite alternate;
        }

        .piece.selected img {
            filter: drop-shadow(0 0 8px gold) 
                    drop-shadow(0 0 15px gold)
                    drop-shadow(0 4px 8px rgba(0,0,0,0.5));
        }

        @keyframes bounce {
            from { transform: scale(1.25) translateY(0); }
            to { transform: scale(1.25) translateY(-5px); }
        }

        .piece img {
            width: var(--sprite-size);
            height: var(--sprite-size);
            image-rendering: pixelated;
            pointer-events: none;
        }

        .piece-icon {
            position: absolute;
            bottom: 0px;
            right: 0px;
            font-size: clamp(16px, 4vw, 24px);
            background: rgba(255,255,255,0.95);
            color: #333;
            border-radius: 50%;
            width: clamp(20px, 5vw, 28px);
            height: clamp(20px, 5vw, 28px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            border: 2px solid #333;
        }

        .piece.red .piece-icon {
            background: #ff6b6b;
            color: white;
            border-color: #c0392b;
        }

        .piece.blue .piece-icon {
            background: #4ecdc4;
            color: white;
            border-color: #1abc9c;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: clamp(0.8rem, 3vw, 1rem);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            touch-action: manipulation;
        }

        #new-game {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            color: white;
        }

        #new-pokemon {
            background: linear-gradient(135deg, #ffcb05, #f0b000);
            color: #3466af;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        #message {
            margin-top: 12px;
            padding: 8px 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            color: white;
            font-size: clamp(0.85rem, 3vw, 1.1rem);
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            width: 100%;
            max-width: 400px;
        }

        .winner-message {
            animation: celebrate 0.5s ease infinite alternate;
        }

        @keyframes celebrate {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        .captured-area {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        .captured {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 12px;
            text-align: center;
            flex: 1;
            min-width: 140px;
            max-width: 250px;
        }

        .captured h4 {
            color: white;
            margin-bottom: 8px;
            font-size: clamp(0.75rem, 2.5vw, 0.9rem);
        }

        .captured-pokemon {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
            min-height: 35px;
        }

        .captured-pokemon img {
            width: clamp(25px, 7vw, 35px);
            height: clamp(25px, 7vw, 35px);
            image-rendering: pixelated;
            opacity: 0.6;
        }

        /* Promotion Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid #ffcb05;
        }

        .modal-content h3 {
            color: #ffcb05;
            margin-bottom: 15px;
        }

        .promotion-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .promotion-option {
            cursor: pointer;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            transition: all 0.3s;
        }

        .promotion-option:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }

        .promotion-option img {
            width: 60px;
            height: 60px;
            image-rendering: pixelated;
        }

        .promotion-option span {
            display: block;
            color: white;
            font-size: 0.8rem;
            margin-top: 5px;
        }

        @media (max-width: 380px) {
            body {
                padding: 10px 5px;
            }
            
            .game-info {
                gap: 10px;
            }
            
            .player-info {
                padding: 8px 10px;
            }
            
            .controls {
                gap: 8px;
            }
            
            button {
                padding: 8px 15px;
            }
        }

        @media (max-height: 500px) and (orientation: landscape) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.2rem;
                margin-bottom: 5px;
            }
            
            .game-info {
                margin-bottom: 8px;
            }
            
            .player-info {
                padding: 5px 10px;
            }
            
            :root {
                --cell-size: min(11vh, 50px);
            }
            
            #message {
                margin-top: 8px;
                padding: 5px 10px;
            }
            
            .controls {
                margin-top: 8px;
            }
        }
    </style>
</head>
<body>
    <h1>‚ö° Pok√©mon Chess ‚ö°</h1>
    
    <div id="loading">
        <div class="pokeball-loader"></div>
        <p>Catching Pok√©mon...</p>
    </div>

    <div id="game-container">
        <div class="game-info">
            <div class="player-info" id="blue-info">
                <h3 class="player-blue">üîµ Blue</h3>
                <small>Legendary Team</small>
            </div>
            <div class="player-info active" id="red-info">
                <h3 class="player-red">üî¥ Red</h3>
                <small>Legendary Team</small>
            </div>
        </div>

        <div id="board"></div>

        <div id="message">Red team's turn - Select a piece</div>

        <div class="controls">
            <button id="new-game">üîÑ New Game</button>
            <button id="new-pokemon">üé≤ New Pok√©mon</button>
        </div>

        <div class="captured-area">
            <div class="captured">
                <h4 class="player-red">Red Captured</h4>
                <div class="captured-pokemon" id="red-captured"></div>
            </div>
            <div class="captured">
                <h4 class="player-blue">Blue Captured</h4>
                <div class="captured-pokemon" id="blue-captured"></div>
            </div>
        </div>
    </div>

    <div class="modal" id="promotion-modal">
        <div class="modal-content">
            <h3>Choose Promotion!</h3>
            <div class="promotion-options" id="promotion-options"></div>
        </div>
    </div>

    <script>
        // Legendary Pokemon IDs
        const LEGENDARY_IDS = [
            144, 145, 146, 150, 151, // Gen 1: Articuno, Zapdos, Moltres, Mewtwo, Mew
            243, 244, 245, 249, 250, 251, // Gen 2: Raikou, Entei, Suicune, Lugia, Ho-Oh, Celebi
            377, 378, 379, 380, 381, 382, 383, 384, 385, 386, // Gen 3
            480, 481, 482, 483, 484, 485, 486, 487, 488, 491, 492, 493, // Gen 4
            638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, // Gen 5
            716, 717, 718, 719, 720, 721, // Gen 6
            785, 786, 787, 788, 789, 790, 791, 792, 800, // Gen 7
        ];

        // Chess piece types
        const PIECE_TYPES = {
            KING: 'king',
            QUEEN: 'queen', 
            ROOK: 'rook',
            BISHOP: 'bishop',
            KNIGHT: 'knight',
            PAWN: 'pawn'
        };

        const PIECE_ICONS = {
            king: '‚ôö',
            queen: '‚ôõ',
            rook: '‚ôú',
            bishop: '‚ôù',
            knight: '‚ôû',
            pawn: '‚ôü'
        };

        // Game State
        let board = [];
        let selectedPiece = null;
        let currentPlayer = 'red';
        let validMoves = [];
        let gameOver = false;
        let lastMove = null;
        let redCaptured = [];
        let blueCaptured = [];
        let promotionPending = null;

        // Pokemon data
        let pokemonData = {
            red: { pawns: [], king: null, queen: null, rook: null, bishop: null, knight: null },
            blue: { pawns: [], king: null, queen: null, rook: null, bishop: null, knight: null }
        };

        // DOM Elements
        const boardEl = document.getElementById('board');
        const messageEl = document.getElementById('message');
        const loadingEl = document.getElementById('loading');
        const gameContainer = document.getElementById('game-container');
        const redInfoEl = document.getElementById('red-info');
        const blueInfoEl = document.getElementById('blue-info');
        const redCapturedEl = document.getElementById('red-captured');
        const blueCapturedEl = document.getElementById('blue-captured');
        const promotionModal = document.getElementById('promotion-modal');
        const promotionOptions = document.getElementById('promotion-options');

        // Fetch Pokemon by ID
        async function fetchPokemon(id) {
            try {
                const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
                const data = await response.json();
                return {
                    id: data.id,
                    name: data.name,
                    sprite: data.sprites.front_default || data.sprites.front_shiny
                };
            } catch (e) {
                console.log(`Failed to fetch Pokemon ${id}`);
                return null;
            }
        }

        // Fetch random Pokemon (non-legendary)
        async function fetchRandomPokemon(count) {
            const pokemon = [];
            const usedIds = new Set(LEGENDARY_IDS);
            
            while (pokemon.length < count) {
                const id = Math.floor(Math.random() * 898) + 1;
                if (usedIds.has(id)) continue;
                usedIds.add(id);
                
                const p = await fetchPokemon(id);
                if (p) pokemon.push(p);
            }
            return pokemon;
        }

        // Fetch random legendaries
        async function fetchRandomLegendaries(count) {
            const shuffled = [...LEGENDARY_IDS].sort(() => Math.random() - 0.5);
            const pokemon = [];
            
            for (let i = 0; i < count && i < shuffled.length; i++) {
                const p = await fetchPokemon(shuffled[i]);
                if (p) pokemon.push(p);
            }
            return pokemon;
        }

        // Initialize the game
        async function initGame() {
            loadingEl.style.display = 'flex';
            gameContainer.classList.remove('visible');
            
            // Fetch pawns (16 random Pokemon, 8 per team)
            const allPawns = await fetchRandomPokemon(16);
            
            // Fetch legendaries (10 total - 5 types x 2 teams)
            const legendaries = await fetchRandomLegendaries(10);
            
            // Assign Pokemon to teams
            pokemonData = {
                red: {
                    pawns: allPawns.slice(0, 8),
                    king: legendaries[0],
                    queen: legendaries[1],
                    rook: legendaries[2],
                    bishop: legendaries[3],
                    knight: legendaries[4]
                },
                blue: {
                    pawns: allPawns.slice(8, 16),
                    king: legendaries[5],
                    queen: legendaries[6],
                    rook: legendaries[7],
                    bishop: legendaries[8],
                    knight: legendaries[9]
                }
            };
            
            loadingEl.style.display = 'none';
            gameContainer.classList.add('visible');
            
            setupBoard();
        }

        // Setup the board
        function setupBoard() {
            board = [];
            boardEl.innerHTML = '';
            selectedPiece = null;
            currentPlayer = 'red';
            validMoves = [];
            gameOver = false;
            lastMove = null;
            redCaptured = [];
            blueCaptured = [];
            redCapturedEl.innerHTML = '';
            blueCapturedEl.innerHTML = '';

            // Initialize empty board
            for (let row = 0; row < 8; row++) {
                board[row] = [];
                for (let col = 0; col < 8; col++) {
                    board[row][col] = null;
                }
            }

            // Place pieces
            // Blue pieces (top, rows 0-1)
            placePieces('blue', 0, 1);
            // Red pieces (bottom, rows 6-7)
            placePieces('red', 7, 6);

            renderBoard();
            updateTurnIndicator();
            updateMessage();
        }

        function placePieces(color, backRow, pawnRow) {
            const data = pokemonData[color];
            
            // Back row: Rook, Knight, Bishop, Queen, King, Bishop, Knight, Rook
            board[backRow][0] = { color, type: PIECE_TYPES.ROOK, pokemon: data.rook, hasMoved: false };
            board[backRow][1] = { color, type: PIECE_TYPES.KNIGHT, pokemon: data.knight };
            board[backRow][2] = { color, type: PIECE_TYPES.BISHOP, pokemon: data.bishop };
            board[backRow][3] = { color, type: PIECE_TYPES.QUEEN, pokemon: data.queen };
            board[backRow][4] = { color, type: PIECE_TYPES.KING, pokemon: data.king, hasMoved: false };
            board[backRow][5] = { color, type: PIECE_TYPES.BISHOP, pokemon: data.bishop };
            board[backRow][6] = { color, type: PIECE_TYPES.KNIGHT, pokemon: data.knight };
            board[backRow][7] = { color, type: PIECE_TYPES.ROOK, pokemon: data.rook, hasMoved: false };

            // Pawns
            for (let col = 0; col < 8; col++) {
                board[pawnRow][col] = { 
                    color, 
                    type: PIECE_TYPES.PAWN, 
                    pokemon: data.pawns[col],
                    hasMoved: false
                };
            }
        }

        // Render the board
        function renderBoard() {
            boardEl.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('touchend', handleCellTouch);

                    // Highlight last move
                    if (lastMove && 
                        ((lastMove.from.row === row && lastMove.from.col === col) ||
                         (lastMove.to.row === row && lastMove.to.col === col))) {
                        cell.classList.add('last-move');
                    }

                    const piece = board[row][col];
                    if (piece) {
                        const pieceEl = createPiece(piece);
                        cell.appendChild(pieceEl);

                        // Highlight king in check
                        if (piece.type === PIECE_TYPES.KING && isInCheck(piece.color)) {
                            cell.classList.add('in-check');
                        }
                    }

                    boardEl.appendChild(cell);
                }
            }

            // Highlight valid moves
            highlightValidMoves();
        }

        // Create a piece element
        function createPiece(piece) {
            const pieceEl = document.createElement('div');
            pieceEl.className = `piece ${piece.color}`;
            
            const img = document.createElement('img');
            img.src = piece.pokemon.sprite;
            img.alt = piece.pokemon.name;
            img.title = `${piece.pokemon.name} (${piece.type})`;
            pieceEl.appendChild(img);

            // Add piece type icon
            const icon = document.createElement('span');
            icon.className = 'piece-icon';
            icon.textContent = PIECE_ICONS[piece.type];
            pieceEl.appendChild(icon);
            
            return pieceEl;
        }

        // Handle touch events
        function handleCellTouch(e) {
            e.preventDefault();
            handleCellClick(e);
        }

        // Handle cell clicks
        function handleCellClick(e) {
            if (gameOver || promotionPending) return;
            
            const cell = e.currentTarget;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const piece = board[row][col];

            // If clicking on a valid move destination
            if (validMoves.some(m => m.row === row && m.col === col)) {
                movePiece(selectedPiece.row, selectedPiece.col, row, col);
                return;
            }

            // Clear previous selection
            clearSelection();

            // If clicking on own piece
            if (piece && piece.color === currentPlayer) {
                selectPiece(row, col);
            }
        }

        // Select a piece
        function selectPiece(row, col) {
            selectedPiece = { row, col };
            validMoves = getValidMoves(row, col);
            
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            const pieceEl = cell.querySelector('.piece');
            if (pieceEl) pieceEl.classList.add('selected');
            
            highlightValidMoves();
        }

        // Clear selection
        function clearSelection() {
            selectedPiece = null;
            validMoves = [];
            document.querySelectorAll('.piece.selected').forEach(p => p.classList.remove('selected'));
            document.querySelectorAll('.cell.valid-move, .cell.valid-capture').forEach(c => {
                c.classList.remove('valid-move', 'valid-capture');
            });
        }

        // Highlight valid moves
        function highlightValidMoves() {
            document.querySelectorAll('.cell.valid-move, .cell.valid-capture').forEach(c => {
                c.classList.remove('valid-move', 'valid-capture');
            });

            validMoves.forEach(move => {
                const cell = document.querySelector(`.cell[data-row="${move.row}"][data-col="${move.col}"]`);
                if (cell) {
                    if (board[move.row][move.col]) {
                        cell.classList.add('valid-capture');
                    } else {
                        cell.classList.add('valid-move');
                    }
                }
            });
        }

        // Get valid moves for a piece
        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];

            let moves = [];

            switch (piece.type) {
                case PIECE_TYPES.PAWN:
                    moves = getPawnMoves(row, col, piece);
                    break;
                case PIECE_TYPES.ROOK:
                    moves = getRookMoves(row, col, piece);
                    break;
                case PIECE_TYPES.KNIGHT:
                    moves = getKnightMoves(row, col, piece);
                    break;
                case PIECE_TYPES.BISHOP:
                    moves = getBishopMoves(row, col, piece);
                    break;
                case PIECE_TYPES.QUEEN:
                    moves = getQueenMoves(row, col, piece);
                    break;
                case PIECE_TYPES.KING:
                    moves = getKingMoves(row, col, piece);
                    break;
            }

            // Filter moves that would leave king in check
            return moves.filter(move => !wouldBeInCheck(row, col, move.row, move.col, piece.color));
        }

        // Pawn moves
        function getPawnMoves(row, col, piece) {
            const moves = [];
            const direction = piece.color === 'red' ? -1 : 1;
            const startRow = piece.color === 'red' ? 6 : 1;

            // Forward move
            if (isValidCell(row + direction, col) && !board[row + direction][col]) {
                moves.push({ row: row + direction, col });
                
                // Double move from start
                if (row === startRow && !board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }

            // Captures
            for (const dc of [-1, 1]) {
                const newCol = col + dc;
                if (isValidCell(row + direction, newCol)) {
                    const target = board[row + direction][newCol];
                    if (target && target.color !== piece.color) {
                        moves.push({ row: row + direction, col: newCol });
                    }
                }
            }

            // En passant
            if (lastMove && lastMove.piece.type === PIECE_TYPES.PAWN &&
                Math.abs(lastMove.from.row - lastMove.to.row) === 2 &&
                lastMove.to.row === row && Math.abs(lastMove.to.col - col) === 1) {
                moves.push({ row: row + direction, col: lastMove.to.col, enPassant: true });
            }

            return moves;
        }

        // Rook moves
        function getRookMoves(row, col, piece) {
            return getSlidingMoves(row, col, piece, [[0, 1], [0, -1], [1, 0], [-1, 0]]);
        }

        // Bishop moves
        function getBishopMoves(row, col, piece) {
            return getSlidingMoves(row, col, piece, [[1, 1], [1, -1], [-1, 1], [-1, -1]]);
        }

        // Queen moves
        function getQueenMoves(row, col, piece) {
            return getSlidingMoves(row, col, piece, [
                [0, 1], [0, -1], [1, 0], [-1, 0],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ]);
        }

        // Sliding piece moves (rook, bishop, queen)
        function getSlidingMoves(row, col, piece, directions) {
            const moves = [];
            
            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                
                while (isValidCell(r, c)) {
                    if (!board[r][c]) {
                        moves.push({ row: r, col: c });
                    } else {
                        if (board[r][c].color !== piece.color) {
                            moves.push({ row: r, col: c });
                        }
                        break;
                    }
                    r += dr;
                    c += dc;
                }
            }
            
            return moves;
        }

        // Knight moves
        function getKnightMoves(row, col, piece) {
            const moves = [];
            const offsets = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];

            for (const [dr, dc] of offsets) {
                const r = row + dr;
                const c = col + dc;
                
                if (isValidCell(r, c) && (!board[r][c] || board[r][c].color !== piece.color)) {
                    moves.push({ row: r, col: c });
                }
            }
            
            return moves;
        }

        // King moves
        function getKingMoves(row, col, piece) {
            const moves = [];
            
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    
                    const r = row + dr;
                    const c = col + dc;
                    
                    if (isValidCell(r, c) && (!board[r][c] || board[r][c].color !== piece.color)) {
                        moves.push({ row: r, col: c });
                    }
                }
            }

            // Castling
            if (!piece.hasMoved && !isInCheck(piece.color)) {
                // Kingside
                if (canCastle(row, col, row, 7)) {
                    moves.push({ row, col: col + 2, castle: 'kingside' });
                }
                // Queenside
                if (canCastle(row, col, row, 0)) {
                    moves.push({ row, col: col - 2, castle: 'queenside' });
                }
            }
            
            return moves;
        }

        // Check if castling is possible
        function canCastle(kingRow, kingCol, rookRow, rookCol) {
            const rook = board[rookRow][rookCol];
            if (!rook || rook.type !== PIECE_TYPES.ROOK || rook.hasMoved) return false;

            const direction = rookCol > kingCol ? 1 : -1;
            const color = board[kingRow][kingCol].color;

            // Check if path is clear
            for (let c = kingCol + direction; c !== rookCol; c += direction) {
                if (board[kingRow][c]) return false;
            }

            // Check if king passes through check
            for (let c = kingCol; c !== kingCol + 3 * direction; c += direction) {
                if (c < 0 || c > 7) break;
                if (wouldBeInCheck(kingRow, kingCol, kingRow, c, color)) return false;
            }

            return true;
        }

        // Check if cell is valid
        function isValidCell(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        // Check if a move would leave the king in check
        function wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
            // Simulate the move
            const originalFrom = board[fromRow][fromCol];
            const originalTo = board[toRow][toCol];
            
            board[toRow][toCol] = originalFrom;
            board[fromRow][fromCol] = null;
            
            const inCheck = isInCheck(color);
            
            // Undo the move
            board[fromRow][fromCol] = originalFrom;
            board[toRow][toCol] = originalTo;
            
            return inCheck;
        }

        // Check if a color's king is in check
        function isInCheck(color) {
            // Find king
            let kingRow, kingCol;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === color && piece.type === PIECE_TYPES.KING) {
                        kingRow = r;
                        kingCol = c;
                        break;
                    }
                }
            }

            // Check if any opponent piece can capture the king
            const opponent = color === 'red' ? 'blue' : 'red';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === opponent) {
                        const moves = getRawMoves(r, c, piece);
                        if (moves.some(m => m.row === kingRow && m.col === kingCol)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // Get raw moves without check validation (to avoid infinite recursion)
        function getRawMoves(row, col, piece) {
            switch (piece.type) {
                case PIECE_TYPES.PAWN:
                    // Only captures for check detection
                    const direction = piece.color === 'red' ? -1 : 1;
                    const moves = [];
                    for (const dc of [-1, 1]) {
                        if (isValidCell(row + direction, col + dc)) {
                            moves.push({ row: row + direction, col: col + dc });
                        }
                    }
                    return moves;
                case PIECE_TYPES.ROOK:
                    return getRookMoves(row, col, piece);
                case PIECE_TYPES.KNIGHT:
                    return getKnightMoves(row, col, piece);
                case PIECE_TYPES.BISHOP:
                    return getBishopMoves(row, col, piece);
                case PIECE_TYPES.QUEEN:
                    return getQueenMoves(row, col, piece);
                case PIECE_TYPES.KING:
                    const kingMoves = [];
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const r = row + dr, c = col + dc;
                            if (isValidCell(r, c)) kingMoves.push({ row: r, col: c });
                        }
                    }
                    return kingMoves;
            }
            return [];
        }

        // Move a piece
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const move = validMoves.find(m => m.row === toRow && m.col === toCol);
            const piece = board[fromRow][fromCol];
            const captured = board[toRow][toCol];

            // Handle en passant capture
            if (move.enPassant) {
                const capturedPawn = board[fromRow][toCol];
                addCaptured(capturedPawn);
                board[fromRow][toCol] = null;
            }

            // Handle regular capture
            if (captured) {
                addCaptured(captured);
            }

            // Handle castling
            if (move.castle) {
                const rookCol = move.castle === 'kingside' ? 7 : 0;
                const newRookCol = move.castle === 'kingside' ? 5 : 3;
                const rook = board[toRow][rookCol];
                board[toRow][newRookCol] = rook;
                board[toRow][rookCol] = null;
                rook.hasMoved = true;
            }

            // Move the piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            piece.hasMoved = true;

            // Record last move
            lastMove = {
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: piece
            };

            // Check for pawn promotion
            if (piece.type === PIECE_TYPES.PAWN && (toRow === 0 || toRow === 7)) {
                showPromotionModal(toRow, toCol, piece);
                return;
            }

            finishMove();
        }

        // Add to captured pieces
        function addCaptured(piece) {
            if (piece.color === 'red') {
                blueCaptured.push(piece);
                const img = document.createElement('img');
                img.src = piece.pokemon.sprite;
                img.title = piece.pokemon.name;
                blueCapturedEl.appendChild(img);
            } else {
                redCaptured.push(piece);
                const img = document.createElement('img');
                img.src = piece.pokemon.sprite;
                img.title = piece.pokemon.name;
                redCapturedEl.appendChild(img);
            }
        }

        // Show promotion modal
        function showPromotionModal(row, col, piece) {
            promotionPending = { row, col, piece };
            promotionOptions.innerHTML = '';

            const promotionTypes = [
                { type: PIECE_TYPES.QUEEN, pokemon: pokemonData[piece.color].queen },
                { type: PIECE_TYPES.ROOK, pokemon: pokemonData[piece.color].rook },
                { type: PIECE_TYPES.BISHOP, pokemon: pokemonData[piece.color].bishop },
                { type: PIECE_TYPES.KNIGHT, pokemon: pokemonData[piece.color].knight }
            ];

            promotionTypes.forEach(({ type, pokemon }) => {
                const option = document.createElement('div');
                option.className = 'promotion-option';
                option.innerHTML = `
                    <img src="${pokemon.sprite}" alt="${pokemon.name}">
                    <span>${PIECE_ICONS[type]} ${type}</span>
                `;
                option.addEventListener('click', () => promotePawn(type, pokemon));
                promotionOptions.appendChild(option);
            });

            promotionModal.classList.add('active');
        }

        // Promote pawn
        function promotePawn(type, pokemon) {
            const { row, col, piece } = promotionPending;
            board[row][col] = {
                color: piece.color,
                type: type,
                pokemon: pokemon,
                hasMoved: true
            };
            
            promotionModal.classList.remove('active');
            promotionPending = null;
            finishMove();
        }

        // Finish the move
        function finishMove() {
            clearSelection();
            currentPlayer = currentPlayer === 'red' ? 'blue' : 'red';
            renderBoard();
            updateTurnIndicator();
            checkGameEnd();
        }

        // Update turn indicator
        function updateTurnIndicator() {
            redInfoEl.classList.toggle('active', currentPlayer === 'red');
            blueInfoEl.classList.toggle('active', currentPlayer === 'blue');
        }

        // Update message
        function updateMessage() {
            const color = currentPlayer === 'red' ? 'Red' : 'Blue';
            messageEl.textContent = `${color} team's turn - Select a piece`;
        }

        // Check for checkmate or stalemate
        function checkGameEnd() {
            // Check if current player has any legal moves
            let hasLegalMove = false;
            
            for (let r = 0; r < 8 && !hasLegalMove; r++) {
                for (let c = 0; c < 8 && !hasLegalMove; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === currentPlayer) {
                        const moves = getValidMoves(r, c);
                        if (moves.length > 0) hasLegalMove = true;
                    }
                }
            }

            if (!hasLegalMove) {
                gameOver = true;
                if (isInCheck(currentPlayer)) {
                    const winner = currentPlayer === 'red' ? 'Blue' : 'Red';
                    messageEl.innerHTML = `üèÜ <span class="winner-message">Checkmate! ${winner} Wins!</span> üèÜ`;
                } else {
                    messageEl.innerHTML = `ü§ù <span class="winner-message">Stalemate! It's a draw!</span> ü§ù`;
                }
            } else if (isInCheck(currentPlayer)) {
                const color = currentPlayer === 'red' ? 'Red' : 'Blue';
                messageEl.textContent = `‚ö†Ô∏è ${color} is in CHECK!`;
            } else {
                updateMessage();
            }
        }

        // Event Listeners
        document.getElementById('new-game').addEventListener('click', setupBoard);
        document.getElementById('new-pokemon').addEventListener('click', initGame);
        
        // Also add touch support for buttons
        document.getElementById('new-game').addEventListener('touchend', function(e) {
            e.preventDefault();
            setupBoard();
        });
        document.getElementById('new-pokemon').addEventListener('touchend', function(e) {
            e.preventDefault();
            initGame();
        });

        // Prevent double-tap zoom on mobile (board only)
        document.addEventListener('touchend', function(e) {
            if (e.target.closest('#board')) {
                e.preventDefault();
            }
        }, { passive: false });

        // Start the game
        initGame();
    </script>
</body>
</html>
